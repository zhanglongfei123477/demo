{"ast":null,"code":"import { throttle } from 'throttle-debounce';\nexport default {\n  data() {\n    return {\n      allSanxins: [],\n      // 所有数据\n      itemHiehgt: 150,\n      // 列表每一项的宽度\n      boxHeight: 0,\n      // 可视区域的高度\n      startIndex: 0 // 元素开始索引\n\n    };\n  },\n\n  created() {\n    // 模拟请求数据\n    this.getAllSanxin(30);\n  },\n\n  mounted() {\n    // 在mounted时获取可视区域的高度\n    this.getScrollBoxHeight(); // 监听屏幕变化以及旋转，都要重新获取可视区域的高度\n\n    window.onresize = this.getScrollBoxHeight;\n    window.onorientationchange = this.getScrollBoxHeight;\n  },\n\n  methods: {\n    getAllSanxin(count) {\n      // 模拟获取数据\n      const length = this.allSanxins.length;\n\n      for (let i = 0; i < count; i++) {\n        this.allSanxins.push({\n          id: `sanxin${length + i}`,\n          msg: `我是三心${length + i}号`,\n          // 这里随便选一张图片就行\n          src: require(\"../assets/logo.png\").default\n        });\n      }\n    },\n\n    // 使用节流，提高性能\n    doScroll: throttle(function () {\n      // 监听可视区域的滚动事件\n      // 公式：~~(滚动的距离 / 列表项 )，就能算出已经滚过了多少个列表项，也就能知道现在的startIndex是多少\n      // 例如我滚动条滚过了160px，那么index就是1，因为此时第一个列表项已经被滚上去了，可视区域里的第一项的索引是1\n      const index = ~~(this.$refs.scrollBox.scrollTop / this.itemHiehgt);\n      if (index === this.startIndex) return;\n      this.startIndex = index;\n\n      if (this.startIndex + this.itemNum > this.allSanxins.length - 1) {\n        this.getAllSanxin(30);\n      }\n    }, 200),\n\n    getScrollBoxHeight() {\n      // 获取可视区域的高度\n      this.boxHeight = this.$refs.scrollBox.clientHeight;\n    }\n\n  },\n  computed: {\n    itemNum() {\n      // 可视区域可展示多少个列表项？ 计算公式：~~(可视化区域高度 / 列表项高度) + 2\n      // ~~是向下取整的运算符，等同于Math.floor()，为什么要 +2 ，是因为可能最上面和最下面的元素都只展示一部分\n      return ~~(this.boxHeight / this.itemHiehgt) + 2;\n    },\n\n    endIndex() {\n      // endIndex的计算公式：(开始索引 + 可视区域可展示多少个列表项 * 2)\n      // 比如可视区域可展示8个列表项，startIndex是0的话endIndex就是0 + 8 * 2 = 16，startIndex是1的话endIndex就是1 + 8 * 2 = 17，以此类推\n      // 为什么要乘2呢，因为这样的话可以预加载出一页的数据，防止滚动过快，出现暂时白屏现象\n      let index = this.startIndex + this.itemNum * 2;\n\n      if (!this.allSanxins[index]) {\n        // 到底的情况，比如startIndex是99995，那么endIndex本应该是99995 + 8 * 2 = 10011\n        // 但是列表数据总数只有10000条，此时就需要让endIndex = (列表数据长度 - 1)\n        index = this.allSanxins.length - 1;\n      }\n\n      return index;\n    },\n\n    tempSanxins() {\n      //   可视区域展示的截取数据，使用了数组的slice方法，不改变原数组又能截取\n      let startIndex = 0;\n\n      if (this.startIndex <= this.itemNum) {\n        startIndex = 0;\n      } else {\n        startIndex = this.startIndex + this.itemNum;\n      }\n\n      return this.allSanxins.slice(startIndex, this.endIndex + 1);\n    },\n\n    blankStyle() {\n      // 上下方的空白处使用padding来充当\n      let startIndex = 0;\n\n      if (this.startIndex <= this.itemNum) {\n        startIndex = 0;\n      } else {\n        startIndex = this.startIndex - this.itemNum;\n      }\n\n      return {\n        // 上方空白的高度计算公式：(开始index * 列表项高度)\n        // 比如你滚过了3个列表项，那么上方空白区高度就是3 * 150 = 450，这样才能假装10000个数据的滚动状态\n        paddingTop: startIndex * this.itemHiehgt + \"px\",\n        // 下方空白的高度计算公式：(总数据的个数 - 结束index - 1) * 列表项高度\n        // 例如现在结束index是100，那么下方空白高度就是：(10000 - 100 - 1) * 150 = 1,484,850\n        paddingBottom: (this.allSanxins.length - this.endIndex - 1) * this.itemHiehgt + \"px\" // 不要忘了加px哦\n\n      };\n    }\n\n  }\n};","map":{"version":3,"mappings":"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","names":["throttle","data","allSanxins","itemHiehgt","boxHeight","startIndex","created","getAllSanxin","mounted","getScrollBoxHeight","window","onresize","onorientationchange","methods","count","length","i","push","id","msg","src","require","default","doScroll","index","$refs","scrollBox","scrollTop","itemNum","clientHeight","computed","endIndex","tempSanxins","slice","blankStyle","paddingTop","paddingBottom"],"sourceRoot":"","sources":["C:\\Users\\zlf\\Desktop\\Code_snippet\\Css\\xuniliebiao\\src\\components\\HelloWorld.vue"],"sourcesContent":["<template>\n  <div class=\"v-scroll\" @scroll.passive=\"doScroll\" ref=\"scrollBox\">\n    <div :style=\"blankStyle\" style=\"height: 100%\">\n      <div v-for=\"item in tempSanxins\" :key=\"item.id\" class=\"scroll-item\">\n        <span>{{ item.msg }}</span>\n        <img :src=\"item.src\" />\n      </div>\n    </div>\n  </div>\n</template>\n\n\n<script>\nimport { throttle } from 'throttle-debounce';\n\nexport default {\n  data() {\n    return {\n      allSanxins: [], // 所有数据\n      itemHiehgt: 150, // 列表每一项的宽度\n      boxHeight: 0, // 可视区域的高度\n      startIndex: 0, // 元素开始索引\n    };\n  },\n  created() {\n    // 模拟请求数据\n    this.getAllSanxin(30);\n  },\n  mounted() {\n    // 在mounted时获取可视区域的高度\n    this.getScrollBoxHeight();\n    // 监听屏幕变化以及旋转，都要重新获取可视区域的高度\n    window.onresize = this.getScrollBoxHeight;\n    window.onorientationchange = this.getScrollBoxHeight;\n  },\n  methods: {\n    getAllSanxin(count) {\n      // 模拟获取数据\n      const length = this.allSanxins.length;\n      for (let i = 0; i < count; i++) {\n        this.allSanxins.push({\n          id: `sanxin${length + i}`,\n          msg: `我是三心${length + i}号`,\n          // 这里随便选一张图片就行\n          src: require(\"../assets/logo.png\").default,\n        });\n      }\n    },\n    // 使用节流，提高性能\n    doScroll: throttle(function () {\n      // 监听可视区域的滚动事件\n      // 公式：~~(滚动的距离 / 列表项 )，就能算出已经滚过了多少个列表项，也就能知道现在的startIndex是多少\n      // 例如我滚动条滚过了160px，那么index就是1，因为此时第一个列表项已经被滚上去了，可视区域里的第一项的索引是1\n      const index = ~~(this.$refs.scrollBox.scrollTop / this.itemHiehgt);\n      if (index === this.startIndex) return;\n      this.startIndex = index;\n      if (this.startIndex + this.itemNum > this.allSanxins.length - 1) {\n        this.getAllSanxin(30);\n      }\n    }, 200),\n    getScrollBoxHeight() {\n      // 获取可视区域的高度\n      this.boxHeight = this.$refs.scrollBox.clientHeight;\n    },\n  },\n  computed: {\n    itemNum() {\n      // 可视区域可展示多少个列表项？ 计算公式：~~(可视化区域高度 / 列表项高度) + 2\n      // ~~是向下取整的运算符，等同于Math.floor()，为什么要 +2 ，是因为可能最上面和最下面的元素都只展示一部分\n      return ~~(this.boxHeight / this.itemHiehgt) + 2;\n    },\n    endIndex() {\n      // endIndex的计算公式：(开始索引 + 可视区域可展示多少个列表项 * 2)\n      // 比如可视区域可展示8个列表项，startIndex是0的话endIndex就是0 + 8 * 2 = 16，startIndex是1的话endIndex就是1 + 8 * 2 = 17，以此类推\n      // 为什么要乘2呢，因为这样的话可以预加载出一页的数据，防止滚动过快，出现暂时白屏现象\n      let index = this.startIndex + this.itemNum * 2;\n      if (!this.allSanxins[index]) {\n        // 到底的情况，比如startIndex是99995，那么endIndex本应该是99995 + 8 * 2 = 10011\n        // 但是列表数据总数只有10000条，此时就需要让endIndex = (列表数据长度 - 1)\n        index = this.allSanxins.length - 1;\n      }\n      return index;\n    },\n    tempSanxins() {\n      //   可视区域展示的截取数据，使用了数组的slice方法，不改变原数组又能截取\n      let startIndex = 0;\n      if (this.startIndex <= this.itemNum) {\n        startIndex = 0;\n      } else {\n        startIndex = this.startIndex + this.itemNum;\n      }\n      return this.allSanxins.slice(startIndex, this.endIndex + 1);\n    },\n    blankStyle() {\n      // 上下方的空白处使用padding来充当\n      let startIndex = 0;\n      if (this.startIndex <= this.itemNum) {\n        startIndex = 0;\n      } else {\n        startIndex = this.startIndex - this.itemNum;\n      }\n      return {\n        // 上方空白的高度计算公式：(开始index * 列表项高度)\n        // 比如你滚过了3个列表项，那么上方空白区高度就是3 * 150 = 450，这样才能假装10000个数据的滚动状态\n        paddingTop: startIndex * this.itemHiehgt + \"px\",\n        // 下方空白的高度计算公式：(总数据的个数 - 结束index - 1) * 列表项高度\n        // 例如现在结束index是100，那么下方空白高度就是：(10000 - 100 - 1) * 150 = 1,484,850\n        paddingBottom:\n          (this.allSanxins.length - this.endIndex - 1) * this.itemHiehgt + \"px\",\n        // 不要忘了加px哦\n      };\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.v-scroll {\n  height: 100%;\n  /* padding-bottom: 500px; */\n  overflow: auto;\n\n  .scroll-item {\n    height: 148px;\n    /* width: 100%; */\n    border: 1px solid black;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 0 20px;\n\n    img {\n      height: 100%;\n    }\n  }\n}\n</style>\n\n"]},"metadata":{},"sourceType":"module"}